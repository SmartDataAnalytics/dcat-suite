package org.aksw.dcat.ap.binding.ckan.rdf_view;

import org.aksw.dcat.ap.binding.jena.domain.impl.RdfDcatApAgentImpl;
import org.aksw.dcat.ap.domain.api.DcatApAgent;
import org.aksw.jena_sparql_api.utils.model.SimpleImplementation;
import org.apache.jena.enhanced.BuiltinPersonalities;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.riot.RDFDataMgr;
import org.apache.jena.riot.RDFFormat;
import org.apache.jena.sys.JenaSystem;

import eu.trentorise.opendata.jackan.model.CkanDataset;


class CompoundGraphView<T> {
	//Map<String, Collection<String>>
	//Map<String, GraphViewFactory<T>> nameToGraphViewFactory

	public void registerGraphView(
			// subject mapping
			String subjectPrefix, // e.g. extra:publisher_
			String subjectIdSuffix, // e.g. uri
			
			// predicate mapping
			String key, // e.g. name
			String property, //
			
			// TODO some converter between map value type and rdf type
			Object valueConverter
	) {
		
	}

	public void createViewForPublisher() {
		//registerGraphView("publisher_",)
	}
}


//class GraphViewFromMapPrefix
//	extends GraphBase
//{
//	// e.g. extra:publisher_uri
//	
//	// we could even support indexed properties: extra:publisher[0]_uri
//	protected String prefix;
//		
//	protected Function<String, String> prefixToUri;
//	
//	// The RDF property generated by this graph
//	protected Node property;
//	
//	// The key (in the extras field) from which to derive the property values
//	protected String key;
//	
//	// TODO Some mapper object
//	
//	
//	/**
//	 * 
//	 * 
//	 * A prefix is implies resources of a certain type e.g.
//	 * extra:publisher_* is the prefix for publishers
//	 * We could register a view: mapper.registerPrefixView("extra:publisher_", Publisher.class)
//	 * Hm, but Jena's RDFNode.canAs(...) feature to dynamically create views is much better
//	 * 
//	 * 
//	 * 
//	 * If the prefix allows only allows for a single subject,
//	 * either
//	 * - there is no prior subject, hence the insert creates it
//	 * - the subject exists but is the same as referenced by the insertion
//	 * - reject the insert otherwise.
//	 * 
//	 * If the prefix allows for multiple values,
//	 * allocate new subjects if they are not present yet.
//	 * This uses the indexed property pattern {prefix}[1]
//	 * 
//	 * 
//	 */
//	@Override
//	public void performAdd(Triple t) {
//		
//		
//		super.performAdd(t);
//	}
//
//	@Override
//	public void performDelete(Triple t) {
//		// TODO Auto-generated method stub
//		super.performDelete(t);
//	}
//	
//	@Override
//	protected ExtendedIterator<Triple> graphBaseFind(Triple t) {
//		Trie<String, Object> map = null;// = new HashMap<>();
//		
//		Map<String, Object> prefixMap = map.prefixMap(prefix);
//
//		Node s = t.getSubject();
//		s = Node.ANY.equals(s) ? null : s;
//		
//		if(s == null) {
//			// list all subjects under the prefix
//			String uri = prefixToUri.apply(prefix);
//			
//			// There is no known uri - yield a blank node from the prefix
//			Node dataS = uri == null
//					? NodeFactory.createBlankNode(prefix)
//					: NodeFactory.createURI(uri);
//				
//			}
//			
//			prefixMap.get(prefix + idSuffix);
//		}
//		
//	}
//	
//}

public class MainUniformApi {
	
	// The main disadvantage with the current approach (abstraction via a model-interfaces) is, how do we map unknown tags on ckan entities
	// to rdf?
	
	// I think in general, if we want to maintain a view-based approach, there is no way around to
	// wrapping the ckan model with a Graph api
	
	
	
	public static void main(String [] args) {
		JenaSystem.init();
		BuiltinPersonalities.model.add(RdfDcatApAgentImpl.class, new SimpleImplementation(RdfDcatApAgentImpl::new));
		
		Model model = ModelFactory.createDefaultModel();
		
		DcatApAgent rdfPublisher = model.createResource().as(RdfDcatApAgentImpl.class);
		
		rdfPublisher.setHomepage("http://infai.org");
		rdfPublisher.setMbox("mailto:infai@dev.null");
		rdfPublisher.setName("InfAI");
	
		RDFDataMgr.write(System.out, model, RDFFormat.TURTLE_PRETTY);
		//FoafAgent foafAgent = 
		
		
		CkanDataset ckanDataset = new CkanDataset();
		//AccessorSupplier<String> accessorSupplier = new AccessSupplierCkanDataset(ckanDataset);
		
//		DcatApAgent ckanPublisher = new FoafAgentAccessorFromCkanDataset("extra:publisher_", accessorSupplier);
//		ckanPublisher.setHomepage("http://uni-leipzig.de");
//		ckanPublisher.setMbox("mailto:uni-le@dev.null");
//		ckanPublisher.setName("University of Leipzig");

		System.out.println();
		System.out.println("extras:");
		ckanDataset.getExtras().stream().map(x -> x.getKey() + " -> " + x.getValue()).forEach(System.out::println);

//		Gson gson = new Gson();
//		String xx = gson.toJson(ckanPublisher);
//	System.out.println(xx);
		
//		try {
//			BeanUtils.copyProperties(ckanPublisher, rdfPublisher);
//		} catch (Exception e) {
//			throw new RuntimeException(e);
//		}
		
//		copyFields(rdfPublisher, ckanPublisher);

		System.out.println();
		System.out.println("extras:");
		ckanDataset.getExtras().stream().map(x -> x.getKey() + " -> " + x.getValue()).forEach(System.out::println);

		RDFDataMgr.write(System.out, model, RDFFormat.TURTLE_PRETTY);

	}

	public static void copyFields(DcatApAgent dst, DcatApAgent src) {
		dst.setHomepage(src.getHomepage());
		dst.setMbox(src.getMbox());
		dst.setName(src.getName());
		dst.setType(src.getType());

	}
}
